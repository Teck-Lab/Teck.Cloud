name: Build and Publish Docker Images

on:
  workflow_run:
    workflows: ["Release"]
    types:
      - completed
    branches:
      - main
      - next
      - alpha
      - beta

permissions:
  contents: read
  packages: write
  id-token: write  # Required for cosign's keyless signing

env:
  REGISTRY: ghcr.io

jobs:
  find-services:
    name: Find All Services
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    outputs:
      services: ${{ steps.find.outputs.services }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Find all services
        id: find
        run: |
          # Find all directories in src/services/*/*.Api with Dockerfiles
          SERVICES=()
          for api_dir in src/services/*/*.Api; do
            if [ -f "$api_dir/Dockerfile" ]; then
              # Extract service name (e.g., src/services/catalog/Catalog.Api -> catalog)
              SERVICE_NAME=$(echo "$api_dir" | sed -n 's|src/services/\([^/]*\)/.*|\1|p')
              if [ -n "$SERVICE_NAME" ]; then
                echo "Found service: $SERVICE_NAME"
                SERVICES+=("$SERVICE_NAME")
              fi
            fi
          done
          
          # Convert to JSON array
          SERVICES_JSON=$(printf '%s\n' "${SERVICES[@]}" | jq -R . | jq -s -c .)
          echo "services=$SERVICES_JSON" >> $GITHUB_OUTPUT
          echo "Services to build: $SERVICES_JSON"

  get-version:
    name: Get Release Version
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    outputs:
      version: ${{ steps.version.outputs.version }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get latest version tag
        id: version
        run: |
          # Get the latest tag (should be from the release that just completed)
          VERSION=$(git describe --tags --abbrev=0 | sed 's/^v//')
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Building version: $VERSION"

  build-and-push:
    name: Build ${{ matrix.service }} (${{ matrix.builder.platform }})
    runs-on: ${{ matrix.builder.runner-image }}
    needs: [find-services, get-version]
    
    # Service containers (needed for Wolverine codegen during build)
    services:
      postgres:
        image: postgres:17-alpine
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: tempdb
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432
      
      rabbitmq:
        image: rabbitmq:3-management-alpine
        env:
          RABBITMQ_DEFAULT_USER: guest
          RABBITMQ_DEFAULT_PASS: guest
        options: >-
          --health-cmd "rabbitmq-diagnostics -q ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5672:5672
          - 15672:15672
    
    strategy:
      matrix:
        service: ${{ fromJson(needs.find-services.outputs.services) }}
        builder:
          - runner-image: ubuntu-24.04
            platform: linux/amd64
          - runner-image: ubuntu-24.04-arm
            platform: linux/arm64
      fail-fast: false
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Find Dockerfile
        id: find-dockerfile
        run: |
          SERVICE_NAME="${{ matrix.service }}"
          
          # Convert service name to PascalCase for .NET project naming convention
          PASCAL_CASE=$(echo "$SERVICE_NAME" | sed 's/\b\(.\)/\u\1/g')
          
          # Common Dockerfile locations (in priority order)
          POSSIBLE_PATHS=(
            "src/services/${SERVICE_NAME}/${PASCAL_CASE}.Api/Dockerfile"
            "src/services/${SERVICE_NAME}/${SERVICE_NAME}.api/Dockerfile"
            "src/services/${SERVICE_NAME}/Dockerfile"
          )
          
          DOCKERFILE_PATH=""
          for path in "${POSSIBLE_PATHS[@]}"; do
            if [ -f "$path" ]; then
              DOCKERFILE_PATH="$path"
              echo "Found Dockerfile at: $DOCKERFILE_PATH"
              break
            fi
          done
          
          if [ -z "$DOCKERFILE_PATH" ]; then
            echo "ERROR: No Dockerfile found for service '$SERVICE_NAME'"
            exit 1
          fi
          
          echo "dockerfile-path=$DOCKERFILE_PATH" >> $GITHUB_OUTPUT

      - name: Prepare environment variables
        run: |
          echo "REPO_LOWER=$(echo '${{ github.repository }}' | tr '[:upper:]' '[:lower:]')" >> $GITHUB_ENV
          echo "PLATFORM_PAIR=$(echo '${{ matrix.builder.platform }}' | sed 's/\//-/')" >> $GITHUB_ENV
          echo "IMAGE_NAME=${{ env.REGISTRY }}/$(echo '${{ github.repository }}' | tr '[:upper:]' '[:lower:]')/${{ matrix.service }}" >> $GITHUB_ENV

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Docker metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.REPO_LOWER }}/${{ matrix.service }}
          tags: |
            type=semver,pattern={{version}},value=${{ needs.get-version.outputs.version }}
            type=semver,pattern={{major}}.{{minor}},value=${{ needs.get-version.outputs.version }}
            type=semver,pattern={{major}},value=${{ needs.get-version.outputs.version }}
            type=raw,value=latest,enable=${{ github.ref == 'refs/heads/main' }}
          labels: |
            org.opencontainers.image.title=${{ matrix.service }}
            org.opencontainers.image.description=Teck Cloud microservice - ${{ matrix.service }}
            org.opencontainers.image.vendor=Teck
            com.teck.service.name=${{ matrix.service }}
            com.teck.build.workflow=${{ github.workflow }}
            com.teck.build.run-id=${{ github.run_id }}
            com.teck.build.run-number=${{ github.run_number }}

      - name: Build and push by digest
        id: build
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ${{ steps.find-dockerfile.outputs.dockerfile-path }}
          platforms: ${{ matrix.builder.platform }}
          labels: ${{ steps.meta.outputs.labels }}
          outputs: type=image,name=${{ env.REGISTRY }}/${{ env.REPO_LOWER }}/${{ matrix.service }},push-by-digest=true,name-canonical=true,push=true
          cache-from: type=gha,scope=${{ matrix.service }}-${{ matrix.builder.platform }}
          cache-to: type=gha,mode=max,scope=${{ matrix.service }}-${{ matrix.builder.platform }}
          network: host
          build-args: |
            VERSION=${{ needs.get-version.outputs.version }}
            BUILD_DATE=${{ fromJSON(steps.meta.outputs.json).labels['org.opencontainers.image.created'] }}
            VCS_REF=${{ github.sha }}
            VCS_URL=${{ github.server_url }}/${{ github.repository }}
            WEBSITE_URL=https://teck.dk
            DOCS_URL=https://docs.teck.dk
            POSTGRES_CONNECTION=Host=localhost;Port=5432;Database=tempdb;Username=postgres;Password=postgres
            RABBITMQ_CONNECTION=amqp://guest:guest@localhost:5672/

      - name: Export digest
        run: |
          mkdir -p /tmp/digests/${{ matrix.service }}
          digest="${{ steps.build.outputs.digest }}"
          touch "/tmp/digests/${{ matrix.service }}/${digest#sha256:}"

      - name: Upload digest
        uses: actions/upload-artifact@v4
        with:
          name: digests-${{ matrix.service }}-${{ env.PLATFORM_PAIR }}
          path: /tmp/digests/${{ matrix.service }}/*
          if-no-files-found: error
          retention-days: 1

  merge-and-tag:
    name: Merge ${{ matrix.service }} manifests
    runs-on: ubuntu-latest
    needs: [find-services, get-version, build-and-push]
    strategy:
      matrix:
        service: ${{ fromJson(needs.find-services.outputs.services) }}
      fail-fast: false
    outputs:
      image-digest-${{ matrix.service }}: ${{ steps.merge.outputs.digest }}
    steps:
      - name: Download digests for ${{ matrix.service }}
        uses: actions/download-artifact@v4
        with:
          path: /tmp/digests
          pattern: digests-${{ matrix.service }}-*
          merge-multiple: true

      - name: Prepare environment variables
        run: |
          echo "REPO_LOWER=$(echo '${{ github.repository }}' | tr '[:upper:]' '[:lower:]')" >> $GITHUB_ENV

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Docker metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.REPO_LOWER }}/${{ matrix.service }}
          tags: |
            type=semver,pattern={{version}},value=${{ needs.get-version.outputs.version }}
            type=semver,pattern={{major}}.{{minor}},value=${{ needs.get-version.outputs.version }}
            type=semver,pattern={{major}},value=${{ needs.get-version.outputs.version }}
            type=raw,value=latest,enable=${{ github.ref == 'refs/heads/main' }}

      - name: Create manifest list and push
        id: merge
        working-directory: /tmp/digests
        run: |
          # Create the manifest and capture the digest
          MANIFEST_OUTPUT=$(docker buildx imagetools create $(jq -cr '.tags | map("-t " + .) | join(" ")' <<< "$DOCKER_METADATA_OUTPUT_JSON") \
            $(printf '${{ env.REGISTRY }}/${{ env.REPO_LOWER }}/${{ matrix.service }}@sha256:%s ' *))
          
          # Extract digest from output
          DIGEST=$(echo "$MANIFEST_OUTPUT" | grep -oP 'sha256:[a-f0-9]{64}' | head -n1)
          echo "digest=$DIGEST" >> $GITHUB_OUTPUT
          echo "Image digest: $DIGEST"

      - name: Inspect image
        run: |
          docker buildx imagetools inspect ${{ env.REGISTRY }}/${{ env.REPO_LOWER }}/${{ matrix.service }}:${{ needs.get-version.outputs.version }}

  scan-image:
    name: Scan ${{ matrix.service }} for vulnerabilities
    runs-on: ubuntu-latest
    needs: [find-services, get-version, merge-and-tag]
    strategy:
      matrix:
        service: ${{ fromJson(needs.find-services.outputs.services) }}
      fail-fast: false
    permissions:
      contents: read
      security-events: write
    steps:
      - name: Prepare environment variables
        run: |
          echo "REPO_LOWER=$(echo '${{ github.repository }}' | tr '[:upper:]' '[:lower:]')" >> $GITHUB_ENV
          echo "IMAGE_NAME=${{ env.REGISTRY }}/$(echo '${{ github.repository }}' | tr '[:upper:]' '[:lower:]')/${{ matrix.service }}" >> $GITHUB_ENV

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@0.31.0
        with:
          image-ref: ${{ env.IMAGE_NAME }}:${{ needs.get-version.outputs.version }}
          format: 'sarif'
          output: 'trivy-results.sarif'
          severity: 'CRITICAL,HIGH'
          exit-code: 1
          ignore-unfixed: true

      - name: Upload Trivy scan results to Security tab
        if: always()
        uses: github/codeql-action/upload-sarif@v4
        with:
          sarif_file: 'trivy-results.sarif'
          category: 'trivy-image-${{ matrix.service }}'

      - name: Run Trivy vulnerability scanner (JSON report)
        if: always()
        uses: aquasecurity/trivy-action@0.31.0
        with:
          image-ref: ${{ env.IMAGE_NAME }}:${{ needs.get-version.outputs.version }}
          format: 'json'
          output: 'trivy-results.json'
          severity: 'CRITICAL,HIGH,MEDIUM'
          ignore-unfixed: true

      - name: Upload Trivy JSON report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: trivy-scan-${{ matrix.service }}-${{ needs.get-version.outputs.version }}
          path: trivy-results.json
          retention-days: 90

  sign-image:
    name: Sign ${{ matrix.service }} image
    runs-on: ubuntu-latest
    needs: [find-services, get-version, merge-and-tag, scan-image]
    strategy:
      matrix:
        service: ${{ fromJson(needs.find-services.outputs.services) }}
      fail-fast: false
    steps:
      - name: Prepare environment variables
        run: |
          echo "REPO_LOWER=$(echo '${{ github.repository }}' | tr '[:upper:]' '[:lower:]')" >> $GITHUB_ENV
          echo "IMAGE_NAME=${{ env.REGISTRY }}/$(echo '${{ github.repository }}' | tr '[:upper:]' '[:lower:]')/${{ matrix.service }}" >> $GITHUB_ENV

      - name: Install Cosign
        uses: sigstore/cosign-installer@v3.7.0

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Get image digest
        id: digest
        run: |
          # Get the digest for this specific service
          DIGEST=$(docker manifest inspect ${{ env.IMAGE_NAME }}:${{ needs.get-version.outputs.version }} | jq -r '.manifests[0].digest' || echo "")
          if [ -z "$DIGEST" ]; then
            echo "Failed to get image digest"
            exit 1
          fi
          echo "digest=$DIGEST" >> $GITHUB_OUTPUT
          echo "Image digest: $DIGEST"

      - name: Sign the container image
        run: |
          # Sign the image digest (multi-arch manifest)
          cosign sign --yes \
            ${{ env.IMAGE_NAME }}@${{ steps.digest.outputs.digest }}
        env:
          COSIGN_EXPERIMENTAL: 1

      - name: Verify signature
        run: |
          # Verify the signature was created successfully
          cosign verify \
            --certificate-identity=https://github.com/${{ github.repository }}/.github/workflows/docker-publish.yaml@${{ github.ref }} \
            --certificate-oidc-issuer=https://token.actions.githubusercontent.com \
            ${{ env.IMAGE_NAME }}@${{ steps.digest.outputs.digest }}
        env:
          COSIGN_EXPERIMENTAL: 1

      - name: Generate SBOM (Software Bill of Materials)
        uses: anchore/sbom-action@v0.17.10
        with:
          image: ${{ env.IMAGE_NAME }}:${{ needs.get-version.outputs.version }}
          format: spdx-json
          output-file: sbom.spdx.json

      - name: Attach SBOM to image
        run: |
          cosign attach sbom --sbom sbom.spdx.json \
            ${{ env.IMAGE_NAME }}@${{ steps.digest.outputs.digest }}
        env:
          COSIGN_EXPERIMENTAL: 1

      - name: Sign SBOM
        run: |
          cosign sign --yes \
            --attachment sbom \
            ${{ env.IMAGE_NAME }}@${{ steps.digest.outputs.digest }}
        env:
          COSIGN_EXPERIMENTAL: 1

      - name: Upload SBOM artifact
        uses: actions/upload-artifact@v4
        with:
          name: sbom-${{ matrix.service }}-${{ needs.get-version.outputs.version }}
          path: sbom.spdx.json
          retention-days: 90
