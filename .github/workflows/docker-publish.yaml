name: Build and Publish Docker Images

on:
  push:
    tags:
      - '*@v*.*.*'      # Matches any service with stable version (e.g., catalog@v1.2.3)
      - '*@v*.*.*-*'    # Matches any service with pre-release (e.g., catalog@v1.2.3-next.1)

permissions:
  contents: read
  packages: write
  id-token: write  # Required for cosign's keyless signing

env:
  REGISTRY: ghcr.io

jobs:
  parse-tag:
    name: Parse Tag and Extract Service Info
    runs-on: ubuntu-latest
    outputs:
      service-name: ${{ steps.parse.outputs.service-name }}
      version: ${{ steps.parse.outputs.version }}
      dockerfile-path: ${{ steps.find-dockerfile.outputs.dockerfile-path }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Parse tag
        id: parse
        run: |
          TAG="${GITHUB_REF#refs/tags/}"
          echo "Full tag: $TAG"
          
          # Extract service name and version (e.g., catalog@v1.2.0 -> catalog, 1.2.0)
          # Also handles pre-release tags like catalog@v1.2.0-next.1
          SERVICE_NAME=$(echo "$TAG" | cut -d'@' -f1)
          VERSION=$(echo "$TAG" | cut -d'@' -f2 | sed 's/^v//')
          
          echo "service-name=$SERVICE_NAME" >> $GITHUB_OUTPUT
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Service: $SERVICE_NAME, Version: $VERSION"

      - name: Find Dockerfile
        id: find-dockerfile
        run: |
          SERVICE_NAME="${{ steps.parse.outputs.service-name }}"
          
          # Convert service name to PascalCase for .NET project naming convention
          # e.g., catalog -> Catalog, inventory -> Inventory
          PASCAL_CASE=$(echo "$SERVICE_NAME" | sed 's/\b\(.\)/\u\1/g')
          
          # Common Dockerfile locations (in priority order)
          POSSIBLE_PATHS=(
            "src/services/${SERVICE_NAME}/${PASCAL_CASE}.Api/Dockerfile"
            "src/services/${SERVICE_NAME}/${SERVICE_NAME}.api/Dockerfile"
            "src/services/${SERVICE_NAME}/Dockerfile"
            "src/${SERVICE_NAME}/Dockerfile"
          )
          
          DOCKERFILE_PATH=""
          for path in "${POSSIBLE_PATHS[@]}"; do
            if [ -f "$path" ]; then
              DOCKERFILE_PATH="$path"
              echo "Found Dockerfile at: $DOCKERFILE_PATH"
              break
            fi
          done
          
          if [ -z "$DOCKERFILE_PATH" ]; then
            echo "ERROR: No Dockerfile found for service '$SERVICE_NAME'"
            echo "Searched in:"
            printf '%s\n' "${POSSIBLE_PATHS[@]}"
            exit 1
          fi
          
          echo "dockerfile-path=$DOCKERFILE_PATH" >> $GITHUB_OUTPUT

  build-and-push:
    name: Build and Push Docker Image
    runs-on: ${{ matrix.builder.runner-image }}
    needs: parse-tag
    
    # Service containers (needed for Wolverine codegen during build)
    services:
      postgres:
        image: postgres:17-alpine
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: ${{ needs.parse-tag.outputs.service-name }}
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432
      
      rabbitmq:
        image: rabbitmq:3-management-alpine
        env:
          RABBITMQ_DEFAULT_USER: guest
          RABBITMQ_DEFAULT_PASS: guest
        options: >-
          --health-cmd "rabbitmq-diagnostics -q ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5672:5672
          - 15672:15672
    
    strategy:
      matrix:
        builder:
          - runner-image: ubuntu-24.04
            platform: linux/amd64
          - runner-image: ubuntu-24.04-arm
            platform: linux/arm64
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Prepare environment variables
        run: |
          echo "REPO_LOWER=$(echo '${{ github.repository }}' | tr '[:upper:]' '[:lower:]')" >> $GITHUB_ENV
          echo "PLATFORM_PAIR=$(echo '${{ matrix.builder.platform }}' | sed 's/\//-/')" >> $GITHUB_ENV
          echo "IMAGE_NAME=${{ env.REGISTRY }}/$(echo '${{ github.repository }}' | tr '[:upper:]' '[:lower:]')/${{ needs.parse-tag.outputs.service-name }}" >> $GITHUB_ENV

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Docker metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.REPO_LOWER }}/${{ needs.parse-tag.outputs.service-name }}
          tags: |
            type=semver,pattern={{version}},value=${{ needs.parse-tag.outputs.version }}
            type=semver,pattern={{major}}.{{minor}},value=${{ needs.parse-tag.outputs.version }}
            type=semver,pattern={{major}},value=${{ needs.parse-tag.outputs.version }}
            type=raw,value=latest
          labels: |
            org.opencontainers.image.title=${{ needs.parse-tag.outputs.service-name }}
            org.opencontainers.image.description=Teck Cloud microservice - ${{ needs.parse-tag.outputs.service-name }}
            org.opencontainers.image.vendor=Teck
            com.teck.service.name=${{ needs.parse-tag.outputs.service-name }}
            com.teck.build.workflow=${{ github.workflow }}
            com.teck.build.run-id=${{ github.run_id }}
            com.teck.build.run-number=${{ github.run_number }}

      - name: Build and push by digest
        id: build
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ${{ needs.parse-tag.outputs.dockerfile-path }}
          platforms: ${{ matrix.builder.platform }}
          labels: ${{ steps.meta.outputs.labels }}
          outputs: type=image,name=${{ env.REGISTRY }}/${{ env.REPO_LOWER }}/${{ needs.parse-tag.outputs.service-name }},push-by-digest=true,name-canonical=true,push=true
          cache-from: type=gha
          cache-to: type=gha,mode=max
          network: host
          build-args: |
            VERSION=${{ needs.parse-tag.outputs.version }}
            BUILD_DATE=${{ fromJSON(steps.meta.outputs.json).labels['org.opencontainers.image.created'] }}
            VCS_REF=${{ github.sha }}
            VCS_URL=${{ github.repositoryUrl }}
            WEBSITE_URL=https://teck.dk
            DOCS_URL=https://docs.teck.dk
            POSTGRES_CONNECTION=Host=localhost;Port=5432;Database=${{ needs.parse-tag.outputs.service-name }};Username=postgres;Password=postgres
            RABBITMQ_CONNECTION=amqp://guest:guest@localhost:5672/

      - name: Export digest
        run: |
          mkdir -p /tmp/digests
          digest="${{ steps.build.outputs.digest }}"
          touch "/tmp/digests/${digest#sha256:}"

      - name: Upload digest
        uses: actions/upload-artifact@v4
        with:
          name: digests-${{ env.PLATFORM_PAIR }}
          path: /tmp/digests/*
          if-no-files-found: error
          retention-days: 1

  merge-and-tag:
    name: Merge manifests and push tags
    runs-on: ubuntu-latest
    needs: 
      - parse-tag
      - build-and-push
    outputs:
      image-digest: ${{ steps.merge.outputs.digest }}
    steps:
      - name: Download digests
        uses: actions/download-artifact@v4
        with:
          path: /tmp/digests
          pattern: digests-*
          merge-multiple: true

      - name: Prepare environment variables
        run: |
          echo "REPO_LOWER=$(echo '${{ github.repository }}' | tr '[:upper:]' '[:lower:]')" >> $GITHUB_ENV

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Docker metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.REPO_LOWER }}/${{ needs.parse-tag.outputs.service-name }}
          tags: |
            type=semver,pattern={{version}},value=${{ needs.parse-tag.outputs.version }}
            type=semver,pattern={{major}}.{{minor}},value=${{ needs.parse-tag.outputs.version }}
            type=semver,pattern={{major}},value=${{ needs.parse-tag.outputs.version }}
            type=raw,value=latest

      - name: Create manifest list and push
        id: merge
        working-directory: /tmp/digests
        run: |
          # Create the manifest and capture the digest
          MANIFEST_OUTPUT=$(docker buildx imagetools create $(jq -cr '.tags | map("-t " + .) | join(" ")' <<< "$DOCKER_METADATA_OUTPUT_JSON") \
            $(printf '${{ env.REGISTRY }}/${{ env.REPO_LOWER }}/${{ needs.parse-tag.outputs.service-name }}@sha256:%s ' *))
          
          # Extract digest from output
          DIGEST=$(echo "$MANIFEST_OUTPUT" | grep -oP 'sha256:[a-f0-9]{64}' | head -n1)
          echo "digest=$DIGEST" >> $GITHUB_OUTPUT
          echo "Image digest: $DIGEST"

      - name: Inspect image
        run: |
          docker buildx imagetools inspect ${{ env.REGISTRY }}/${{ env.REPO_LOWER }}/${{ needs.parse-tag.outputs.service-name }}:${{ needs.parse-tag.outputs.version }}

  scan-image:
    name: Scan Docker Image for Vulnerabilities
    runs-on: ubuntu-latest
    needs:
      - parse-tag
      - merge-and-tag
    permissions:
      contents: read
      security-events: write
    steps:
      - name: Prepare environment variables
        run: |
          echo "REPO_LOWER=$(echo '${{ github.repository }}' | tr '[:upper:]' '[:lower:]')" >> $GITHUB_ENV
          echo "IMAGE_NAME=${{ env.REGISTRY }}/$(echo '${{ github.repository }}' | tr '[:upper:]' '[:lower:]')/${{ needs.parse-tag.outputs.service-name }}" >> $GITHUB_ENV

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@0.31.0
        with:
          image-ref: ${{ env.IMAGE_NAME }}:${{ needs.parse-tag.outputs.version }}
          format: 'sarif'
          output: 'trivy-results.sarif'
          severity: 'CRITICAL,HIGH'
          exit-code: 1
          ignore-unfixed: true

      - name: Upload Trivy scan results to Security tab
        if: always()
        uses: github/codeql-action/upload-sarif@v4
        with:
          sarif_file: 'trivy-results.sarif'
          category: 'trivy-image-${{ needs.parse-tag.outputs.service-name }}'

      - name: Run Trivy vulnerability scanner (JSON report)
        if: always()
        uses: aquasecurity/trivy-action@0.31.0
        with:
          image-ref: ${{ env.IMAGE_NAME }}:${{ needs.parse-tag.outputs.version }}
          format: 'json'
          output: 'trivy-results.json'
          severity: 'CRITICAL,HIGH,MEDIUM'
          ignore-unfixed: true

      - name: Upload Trivy JSON report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: trivy-scan-${{ needs.parse-tag.outputs.service-name }}-${{ needs.parse-tag.outputs.version }}
          path: trivy-results.json
          retention-days: 90

      - name: Generate vulnerability summary
        if: always()
        run: |
          cat >> $GITHUB_STEP_SUMMARY << 'EOF'
          ## ðŸ” Security Scan Results
          
          **Image:** `${{ env.IMAGE_NAME }}:${{ needs.parse-tag.outputs.version }}`
          **Digest:** `${{ needs.merge-and-tag.outputs.image-digest }}`
          
          Trivy scan completed. Check the Security tab for detailed results.
          
          Download the full JSON report from the workflow artifacts.
          EOF

  sign-image:
    name: Sign Docker Image with Cosign
    runs-on: ubuntu-latest
    needs:
      - parse-tag
      - merge-and-tag
      - scan-image
    steps:
      - name: Prepare environment variables
        run: |
          echo "REPO_LOWER=$(echo '${{ github.repository }}' | tr '[:upper:]' '[:lower:]')" >> $GITHUB_ENV
          echo "IMAGE_NAME=${{ env.REGISTRY }}/$(echo '${{ github.repository }}' | tr '[:upper:]' '[:lower:]')/${{ needs.parse-tag.outputs.service-name }}" >> $GITHUB_ENV

      - name: Install Cosign
        uses: sigstore/cosign-installer@v3.7.0

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Sign the container image
        run: |
          # Sign the image digest (multi-arch manifest)
          cosign sign --yes \
            ${{ env.IMAGE_NAME }}@${{ needs.merge-and-tag.outputs.image-digest }}
        env:
          COSIGN_EXPERIMENTAL: 1

      - name: Verify signature
        run: |
          # Verify the signature was created successfully
          cosign verify \
            --certificate-identity=https://github.com/${{ github.repository }}/.github/workflows/docker-publish.yaml@${{ github.ref }} \
            --certificate-oidc-issuer=https://token.actions.githubusercontent.com \
            ${{ env.IMAGE_NAME }}@${{ needs.merge-and-tag.outputs.image-digest }}
        env:
          COSIGN_EXPERIMENTAL: 1

      - name: Generate SBOM (Software Bill of Materials)
        uses: anchore/sbom-action@v0.17.10
        with:
          image: ${{ env.IMAGE_NAME }}:${{ needs.parse-tag.outputs.version }}
          format: spdx-json
          output-file: sbom.spdx.json

      - name: Attach SBOM to image
        run: |
          cosign attach sbom --sbom sbom.spdx.json \
            ${{ env.IMAGE_NAME }}@${{ needs.merge-and-tag.outputs.image-digest }}
        env:
          COSIGN_EXPERIMENTAL: 1

      - name: Sign SBOM
        run: |
          cosign sign --yes \
            --attachment sbom \
            ${{ env.IMAGE_NAME }}@${{ needs.merge-and-tag.outputs.image-digest }}
        env:
          COSIGN_EXPERIMENTAL: 1

      - name: Upload SBOM artifact
        uses: actions/upload-artifact@v4
        with:
          name: sbom-${{ needs.parse-tag.outputs.service-name }}-${{ needs.parse-tag.outputs.version }}
          path: sbom.spdx.json
          retention-days: 90

      - name: Create verification instructions
        run: |
          cat >> $GITHUB_STEP_SUMMARY << 'EOF'
          ## ðŸ”’ Image Signed Successfully

          **Image:** `${{ env.IMAGE_NAME }}:${{ needs.parse-tag.outputs.version }}`
          **Digest:** `${{ needs.merge-and-tag.outputs.image-digest }}`

          ### Verify the signature:

          ```bash
          # Using regex pattern (recommended)
          cosign verify \
            --certificate-identity-regexp='^https://github\.com/${{ github.repository }}/\.github/workflows/docker-publish\.yaml@.*$' \
            --certificate-oidc-issuer=https://token.actions.githubusercontent.com \
            ${{ env.IMAGE_NAME }}:${{ needs.parse-tag.outputs.version }}

          # Or with exact tag reference
          cosign verify \
            --certificate-identity=https://github.com/${{ github.repository }}/.github/workflows/docker-publish.yaml@${{ github.ref }} \
            --certificate-oidc-issuer=https://token.actions.githubusercontent.com \
            ${{ env.IMAGE_NAME }}:${{ needs.parse-tag.outputs.version }}
          ```

          ### View the SBOM:

          ```bash
          cosign verify-attestation \
            --type spdx \
            --certificate-identity-regexp='^https://github\.com/${{ github.repository }}/\.github/workflows/docker-publish\.yaml@.*$' \
            --certificate-oidc-issuer=https://token.actions.githubusercontent.com \
            ${{ env.IMAGE_NAME }}:${{ needs.parse-tag.outputs.version }}
          ```

          ### Download the SBOM:

          ```bash
          cosign download sbom ${{ env.IMAGE_NAME }}:${{ needs.parse-tag.outputs.version }} > sbom.json
          ```
          EOF
